
//PATH NIO

1) Path.subpath te da las rutas limpias sin c:\\ ni \ finales 
   sólo intermedias pej: f\salida 
   
    
   Path p1 = Paths.get("c:\\a\\b\\c");
   p1.subpath(1,2) --> b     
   p1.getName(1) --> b
   
2) Path.resolve(string) te devuelve la ruta completa donde está ese fichero,
   precedido con \ruta\string.pdf

3) Path.releativize (p) te da una ruta relativa desde la cual se representa p
   respecto de Path
   
   primero la ruta normaliza y luego se relativiza
   
   ambas (Path y p) deben tener // c:// en su definición para que funciones
   
   Path p1 = Paths.get("photos/goa");         
   Path p2 = Paths.get("/index.html");         
   Path p3 = p1.relativize(p2);    -- FALLO! IllegalArgumentException      
   System.out.println(p3);
   
4) Path p  = Paths.get("c:\\temp\\out"); 
   Files.deleteIfExists(p); --devuelve 
   true si pudo borrarlo por que era un directorio que existía  y estaba vacío
   false si no existía
   DirectoryNotEmptyException si existía pero estaba vacío
   
5)Files.copy (path1, path2, StandardCopyOption.COPY_ATTRIBUTES)
StandardCopyOption.COPY_ATTRIBUTES
	intenta copiar como mínimo la hora de Ãºltima modificación, 
	pero no es seguro pues depende de quÃ© plataforma (SO) y quÃ© atributos 
	de cada fichero maneja
	
6)  var raf = new RandomAccessFile("c:\\temp\\test.txt", "rwd");
	raf.writeChars("hello");
	raf.close();
	
	Si existe el fichero, aÃ±ade al principio
	Si no, intenta crearlo	
	
	el 2Âº param es el modo de acceso, que puede ser
	
	
	"r" --> sólo para leer. al intentar escribir petaría 
	"rw" --> modo lectura escritura. si no existe, lo intenta crear
	"rwd" --> se modifica sincronamente (el fichero real - underliying)
	"rws" --> se modifica síncronamente hasta los metadatos
	
7) Paths.get sí existe
   Path.get NO!!!
   
8) Paths.get("c:\\main\\project\\Starter.java").getname(0) --> main
el prefijo raiz no  es parte del path name 

9) path1.resolve(p2) si p2 es ruta absoluta, te devuelve el mismo p2

10) path.toRealPath() tira una IOException si no existe... hay que gestionarla CHECKED

//SERIALIZACIÓN 

1) Si una clase implementa Seriailzable y detalla estos métodos
son los que se tienen en cuenta al realizar la operación


 private void writeObject(java.io.ObjectOutputStream out)
     throws IOException
 private void readObject(java.io.ObjectInputStream in)
     throws IOException, ClassNotFoundException;
     
// RandomAccessFile


1) RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");--abro en modo lectura escritura
--"r", "rw", "rws" (metadato y datos sycn), o "rwd (datos sync)" son las opciones válidas
 
raf.seek( raf.length() ); --me pongo al final
raf.writeChars("FINAL TEXT");--escribo

2) RandomAccesFile crea un fichero y añade
   FileOutputStream sobreescribe todo

// FILE

new File (File parent, String child) 
new File (Uri parent)
new File (String parent, String child)
new File (String path)
	
//FILES

//te devuelve un path con todos los archivos que tienen extensión gif y jpeg
try{ DirectoryStream<Path> ds = Files.newDirectoryStream(dir, "*.{gif,jpeg}");

//BUFFEREDREADER 

BufferedReader(Reader) que puede ser un mismo BF, ya que es un Reader :)

BufferedReader().lines():Stream<String> existe desde java 1.8


//writeUTF

Es un método de DataOutput, heredado por RandomAccesFile y ObjectOutputStream