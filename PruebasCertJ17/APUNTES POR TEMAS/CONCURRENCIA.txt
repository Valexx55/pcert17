//CALLABLE

1) INTERFAZ callable 

	public interface Callable<V>{ 
  		V call() throws Exception; 	-- ha de devolver el mismo tipo que el valor
	} 								-- parametrizado

	
2) new Thread(() -> {w1.write(d1, d2);}).start(); //válido -- lanza el método run

3) deadlock : dos procesos usan recursos que se bloquean mutuamente sin hacer nada
   livelock : igual, pero los dos procesos van cambiando de estado (analogía pasillo estrecho)
   starvation : un proceso espera que sea él el asignado, pero nunca le toca (a los otro sí) 
   
4) AtomicInteger tiene métodos para añadir uno atómicamente (operación copn estado frente a hilos)
	Por ejemplo, para sumar de a uno
   		
   			- AtomicInteger.addAndGet(1)   			- AtomicInteger.incrementAndGet();
   			
5) Si un método es sync y acaba con una checked exception, 
   el bloqueo es gestioando por el hilo y liberado automáticamente
   
6) Cada hilo tiene su propias variables instancia. Si desde el hilo principal, modifico una variable
   miembro, no es vista desde la ejecución del otro hilo.
  
7) interrupt() marca com ointerrumpido un hilo. isInterrupted() es true
	y sólo lanza excepcón si está en sleep o wait antes. 


8) RUnnable vs Callable 
	
	runnable NO TIRA Excepction CHecked y devuelve void
	Callable SÍ TIRA Exception y devuelve un valor
	
	Executors.newSingleThreadExecutor().execute(Runnable);
	
//ATOMICINTEGER

1)ai.addAndGet(5); suma 5 y devuelve el valor
  a1.incrementAndGet(); suma 1 y devuleve el valor tb

2) ai++ NO COMPILA

3) ai.compareAndSet(viejo, nuevo); si viejo = ai, se pasa a nuevo


//THREAD

1) th.start() --< NOS SE PUEDE LLAMAR 2 VECES A START con el MISMO HILO

2) Thread hilo =  ...
   hilo.interrupt() sólo marca el hilo como interrupmdio
   no salta una la expceción de InterruptedException si el hilo no está en espera o(sleep o wait)

//LOCK
trylock devuelve booleano y si pudo bloquear, bloquea
cada lock/trylock debe llevar su unlock...si no se bloquean 2 y nunca se desbloquea

