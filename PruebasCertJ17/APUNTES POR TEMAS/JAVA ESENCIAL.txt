//ARRAY

1) Array.binarySearch (array, clave) :pos debe etar ordenado para que el método funcione

2) Arrays.mismatch (array1, array2 ) devuelve -1 si los array que compara son oiguales o el índice
	del primer discordante
	
3) Arrays.compare (a1, a2, comaparador? ) : 1, -1 , 0

//STRINGS

1) El método isBlank devuelve true si la cadena está vacía o contiene 
todo espacios blancos

2) Strings son imutables: si le cambias el valor, se crear automáticamente una variable nueva, perservando la orignal
   Esto hace de evitar modificaciones en datos pasados por par�metros
   
   Hacer una clase final evita que pueda heredarse de ella y por tanto, redefinir
   métodos y atributos que pudieran alterar el estado del objeto padre, indirectamente.

3) strip () -- método que quita los espacios por delante y por detrás.

4) substring [) - 1º incluído 2º no incluido

//FINAL

	final aplicado a atributos provoca que no pueda modicarse el valor una vez asignado

	final aplicado a clases hacen que de esa clase no pueda heredarse

	final aplicado a métodos hacen que no puedan sobreescribirse

	En los casos de clases y métodos se persigue facilitar la inmutabilidad
	(que subclases no se pueda modificar el estado de un objeto sin que
	se cree uno nuevo)
	
// NOMENCLATURA

	desde Java 9 no puede usarse el guión bajo sólo como identificador ("_")

//CLASES ESTRUCTURA

1) Puedes declarar tantas clases como quieras en un mismo archivo. El requisito es 
que sólo haya una declarada como pública y coincida con el nombre del fichero

2) No todas las clases deben tener el nombre dentro de su código fuente (pregunta trampa)

Pej: puedes tener una clase anónima que implementa una interfaz y funciona sin ese requisito

	Runnable r = new Runnable(){ public void run(){
	  System.out.print("Do nothing!");
	  }
	};
	r.run();
	
	Aquí r, es una referencia a la clase, pero esa clase, no tiene nombre dentro de ella
	

3) El caracter _ no puede formar parte del nombre de una clase

4) Ninguna palabra clave de Java empieza por mayúscula

5) Ninguna clase a top level puede declarse como protected. Sí package protected o public.

6) Se pueden sobrecargar fuciones llamadas main dentro una clase siempre que se usen
   distintos parámetros
---------------------------------------------------------------------
---------------------------------------------------------------------

//OPERADORES

1) x = y--;  Primero se asigna. Después se decrementa. 
			 x es mayor que y después de la ejecución de esa instrucción
			 
2) Los operadores booleanos tienen más preferencia que una asginación (=)

3) Existe el operador bitewise ~ (complementario, negativo- operación binaria-)

4) ++i == 0; 1 suma y luego compara
   i++ == 0; 1 compara y luego suma
   
5)
	int i = 0; int j = 1; 
	if( (i++ == 0) & (j++ == 2) )
	{
			// 1 --> i = 0, true
			// 2 --> j = 2, false
			// LUEGO true & false --> false
		//NUNCA SE EJECUTA
	} else {
		//SÍ SE EJECUTA
	}
	
6) & o | siempre se ejecuta las dos partes (&& o ||) NO

   con números a los lados & ejecuta la operación AND binaria (BITWISE) - operación bit a bit
   ( 10 & 12 ) = 8 (1010 & 1100) = (1000)  
   con boolean, es un AND lógico, pero ejecuta todas las partes 
   |, igual, pero con OR
   
7) Operadores se evaluan por orden de prioridad.
   Si tienen la misma prioridad, de izquiera a derecha
   
   pej: 3 + 100/10*2-13 = 10 
   //100/10 = 10; 10*2=20; 20+3 = 23; 23 -13 = 10! 

    

---------------------------------------------------------------------
---------------------------------------------------------------------
			 
			 
//SWITCH

1) long, float, double, and boolean NO PUEDEN USARSE NUNCA como variable Switch(v)


---------------------------------------------------------------------
---------------------------------------------------------------------

//FOR

1) 	int i ; 
	for ( i = 4, int t = 6; i < 0; i++ ) --> ILEGAL! no puedes declarar e inicializar mezclados
	
	
//TIPOS

1)Integer.MAX_VALUE+1 = Integer.MIN_VALUE !! --> da la vuelta, alucina :) 


2) return x - 20/x + x*x; //esto se castea automácamente como un INT!!!!


3) n = 1000.0 -- SE INSTANCIA automáticamente como un double! (si no lleva f)
   float n = 10 --sin embargo esto es correcto!
   float d = 0 * 1.5;	esto incorrecto pues se hace como un double

4)  byte b = 1;   char c = 1;   short s = 1;   int i = 1
	s = b * b ; -- incorrecto devuelve un entero
	s *= b ; -- correcto: las asginaciones compuestas hacen un casting explícito
	
5) si haces una división de 
	valor = float / 0 No DA EXCEPCIÓN
	el valor asume constante Float.POSITIVE_INFINITY or negative
	lo cual a su vez hace que Float.isInfinite(valor) de true
	
6) los float tiene precisión de 6 dígits
	si pasas de int a float, se pierde precisión
	y al pasar otra vezde float a int, no se obtiene el mismo número

7) Si usas un número real se instancia como double a no ser que pongas float explícitamente

	double amount = 1000.0; // BIEN
	Double amount = 1000.0; // B
	var amount = 1000.0; // B
	float amount = 1000.0; // X MAL debería llevar f

//ENUM

1) No se puede extender de un enum

//VAR 

1)  for (var i=5; i=0; i--) { } -- incorrecto no puedes asignar a un var 0, porque lo
  								toma como false
  								
2) var n; n = 0; -- INCORRECTO! no se puede declarar var sin inicializar	

3) VAR sólo puede ser usado para variables locales dentro de un método 
  								
  								
  								