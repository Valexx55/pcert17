//STREAMS

1) Map.computeIfAbsent(name, (a)->new ArrayList<Double>()).add(value); 

	computeIfAbsent llama a la función anónima si esa clave (name) no está en el mapa
	y le asocia el valor retornado por la función, devolviendo ese valor 
	(una lista nueva en este caso)

	si ya esta asociado esa clave a un valor, devuelve el valor 
	(una lista "usada" en ese caso) a la que añade un valor

	computeIfAbsent va a devolver o bien el valor asociado a la clave (name)
	o bien el que genere la función anónima si esa clave no existía
	
	rdo: el clásico ejemplo de ECI de agrupar lista de notas de un alumno, 
	pues eso, en una sola linea 
	
	
2) Stream.findAny es un método no determinsta que devuelve aletatoriamente 
   cualquier elemento del flujo.
    
   De hecho La aleatoriedad es algo pretendido
   como anécdota, es una operación intermedia tipo short-circuit
   porque dado un stream largo o infinito, no tiene pq procesarlo entero
   
3) Pipeline - tubería : Normalmente un Stream es el chorro, seguido de operaciones
   intermadias, seguido de una operación final.
   
   Las operaciones intermedias son siempre vagas. Es decir, van de uno en uno, 
   creando un chorro nuevo (stream) con lo que va saliendo 
   
   filter-map-sum se puede hacer de una sola pasada por los datos
   
   3.1) casi todas las operaciones finales son EAGER:
   		completan el recorrido del chorro antes de devolver el resultado


4) Hay operaciones sin estado (statelss) y con estado (statefull)
   Las primeras permiten agurpar operaciones intermedias y tratarse con complejida
   o(1), al permitir concurrencia...no importa cada entrada anterior
   
   Las segundas, pueden requerir varias pasadas o esperar a procesar todo 
   (ordenar, pej)
   
 5) Si una operación intermedia (como sorted) no va seguida de una final, ni se ejecuta
 
 6) Si no asignas las operaciones de un Stream a otro o Lista/Colección, la lista
 	colección original (backing source) no se modifica realmente - su estado -
 	
 7) Si usas una referencia a un método, no puedes hcaerlo con los argumentos y flecha
 
 		a -> Integer::toHexString -- INCORRECTO! - no es posible inferir que a sea el 
 		argumento con el que opera toHexString

 		Integer::toHexString -- CORRECTO!

		(a)-> Integer.toHexString(a) -- CORRECTO!
		
8) Los stream se recorren/crean secuencial (normal) o paralelos (parallelStream)
   Puede alterrarse el orden sobre la marcha con .parallel o .sequential
   Oracle no documenta qué pasa en ese supuesto, pero se puede
   
   Por tanto, esto es correcto
   
   		Stream<Integer> strm2 = strm1.parallel().filter(i->i>5).filter(i->i<15).sequential();
   		
9) java.lang.IllegalStateException: stream has already been operated upon or closed
   No puedo reusar/recorrer dos veces un Stream :S
   
10) strm1.collect(Collectors.partitioningBy(i->{ return i>5 && i<15; }));
    este método de vuelve un Map con clave boolean y lista de valores
    asociados clasificados según si cumplen el criterio o no
    
    si del mapa hago get(true), me estaré quedando con todos los valores
    que cumplen la condición 
    
    collect es una Operación Terminal y reduce el Stream
    se le llama mutable reduction operation porque se crea realmente una nueva lista
    con ese stream, sobre el que se puede operar.
    
11) el método Stream.allMatch (predicado):boolean es una operación terminal y cortocircuito
    es decir, que puede procesar todo un stream o solo un elemento si ya le vale para
    determinar su decisión.
    
12) 
	reduce con 1 parámetro devuelve Optional, con el resto valor
    reduce(BinaryOperator<T> accumulator) : devuelve un OPTIONAL DE T
    reduce(T identity, BinaryOperator<T> accumulator) devuelve un T

13) Collectors.joining() devuelve todos los elementos de un stream juntos en un String 

14) letters.stream().collect(Collectors.groupingBy(a->"")).toString();
    List<String> letters = Arrays.asList("j", "a", "v","a");
    System.out.println(word); // {=[j, a, v, a]}
    
15) UN INTERFAZ FUNCIONAL --> sÃ“LO UN MÃ‰TODO ABSTRACTO (SIN IMPLEMTANAR)
	+ VARIOS STATIC O DEFAULT CON IMPLENTACIÃ“N
	

	A functional interface in Java is an interface that contains only a single abstract (unimplemented)
	method. 
	
	A functional interface can contain default and static methods which do have an 
	implementation, in addition to the single unimplemented method.
	
16) max(Comparador)!!! para que funciones bien

17) groupingBy( Function 1 paramétro / clasificador, collector)
String::equals No vale 2
String::upperCase sí valdría es 1

18) anyMatch devuevell un boolean!!!!!

19) Function<ENTRADA, SALIDA> lleva 2 parámetros"!!"" genéricos

20) sea este método local 

public void remove(List˂Character˃ chars) {
   char end = 'z';
   Predicate˂Character˃ predicate = c -˃ {
      char start = 'a'; return start ˂= c && c ˂= end; };

   // INSERT LINE HERE
   char c = x; ---------> FUNCIONA!!! PQ c, tiene sólo el ámbito de la lambda
}

21)

Employee e = new Employee(); //2        
System.out.println(validateEmployee(e, e->e.age<10000)); //3

fallo, la e de parámetro no puede llamarse e, porque redeclara a e de Emplooyee en la línea antes
las lambas no tienen ámbito propio...

22) 

	Stream<String> ss = Stream.of("a", "b", "c", "d", "e");     
	Spliterator<String> sit1 = ss.spliterator();     
	long s0 = sit1.estimateSize();     
	Spliterator<String> sit2 = sit1.trySplit();     
	long s1 = sit1.estimateSize();     
	long s2 = sit2.estimateSize();          
	System.out.println( s0 - (s1+s2) ); -- al saber el número exacto de elemtentos esto da cero

23) 

Comparator<T> c = Comparator.comparing(Function<T, U)>) donde T es el lo que se compara y U un Comparable

List<Integer> ls = Arrays.asList(10, 47, 33, 23);
ls.stream().max(Comparator.comparing(a->a)).get();

Da 47



//STREAM INT

1) average devuelve un Optional<Double>
   sum devuelve un int!!
   
2) 

System.out.println(ls.stream().max(Integer::max).get()); //2 NO FUNCIONA Integer max no funciona ccomo comparador  
System.out.println(ls.stream().max(Integer::compare).get()); //3 Este sí

max (espera un COMPARADOR) para que la cosa funcione bien
   
3) IntStream.collect NO existe

4) mapToObj... y pasa a Stream<O>    

5) IntStream.reduce (f): OptionalInt

	5.1) IntStream.reduce (v, f1): int
	
6) IntStream.rangeClosed(1,4)--> te da del 1 al 4 incluido

7 ) Collectors.joining() ESPERA Stream˂String˃

8) Stream.iterate(1, x -˃ x++) devuelve 1111111 infinito

8.1) Stream.iterate(1, x -˃ ++x) devuelve 1234567 infinito

9) COllectors.MAP (1K, 2V) --> NO ADMITE CLAVES DUPLICADAS --< LANZA EXception
   COllectors.MAP (1K, 2V, 3MERGE) --> sí ADMITE CLAVES DUPLICADAS

10) Collections.reduce (U, BF<U, I, U>, BC<U>) la función del emdio rx tipos distintos


11) Collector.groupingBy(Null) --> da NullPointerException